snippet imp
import ${0:Data.Text}
endsnippet

snippet import
import           ${0:Data.Text}
endsnippet

snippet import2
import           ${1:Data.Text} (${0:head})
endsnippet

snippet impq
import qualified ${1:Data.Text} as ${0:T}
endsnippet

snippet importq
import qualified ${1:Data.Text} as ${0:T}
endsnippet

snippet module
module ${0:Module.Name} where
endsnippet


snippet if "if ... then ... else ..."
if ${1:condition}
	then ${2:expression}
	else ${3:expression}
endsnippet

snippet case "case ... of ..."
case ${1:expression} of
	${2:pattern} -> ${3:expression}
	${4:pattern} -> ${5:expression}
endsnippet

snippet :: "Type signature"
${1:name} :: ${2:Type} -> ${3:Type}
endsnippet

# type classes are not yet implemented in pakcs and kics2
#snippet => "Type constraint"
#(${1:Class} ${2:a}) => $2
#endsnippet

snippet def "Function definition"
${1:name} :: ${2:Type} -> ${3:Type}
$1 ${4:pattern} = ${5:unknown}
endsnippet

snippet def[] "Function definition for list patterns"
${1:name} :: [${2:Type}] -> ${3:Type}
$1 [] = ${4:unknown}
$1 ${5:(x:xs)} = ${6:unknown}
endsnippet

snippet = "Function clause"
${1:name} ${2:pattern} = ${3:unknown}
endsnippet

snippet 2= "Function clause"
${1:name} ${2:pattern} = ${3:unknown}
$1 ${4:pattern} = ${5:unknown}
endsnippet

snippet 3= "Function clause"
${1:name} ${2:pattern} = ${3:unknown}
$1 ${4:pattern} = ${5:unknown}
$1 ${6:pattern} = ${7:unknown}
endsnippet

snippet | "Guard"
| ${1:predicate} = ${2:unknown}
endsnippet

snippet \ "Lambda expression"
\\${1:pattern} -> ${2:expression}
endsnippet

snippet [|] "List comprehension"
[${3:foo }$1 | ${1:x} <- ${2:xs} ]
endsnippet

snippet let "let ... in ..."
let ${1:name} = ${2:expression}
in ${3:expression}
endsnippet

snippet wh "where x = expression"
where
	${1:name} = ${2:expression}
endsnippet
